LTI MINDTREE INTERVIEW QUESTIONS EXP 3-5 years.

How do you design a fault-tolerant architecture in the cloud?

Ans. Fault Tolerance: means assuming things will fail and ensuring your system continues to operate with minimal disruption.
Design process:
Deploy across multiple Availability Zones (AZs)
Use managed load balancers (e.g., ALB/ELB, Azure Load Balancer)
Health checks automatically route traffic away from unhealthy instances
Autoscaling & Autohealing


How do you manage secrets securely in GitOps or deployment pipelines?

Ans. We can keep secrets in the below :
HashiCorp Vault
AWS Secrets Manager / SSM Parameter Store
Azure Key Vault
GCP Secret Manager

How do you implement blue-green or canary deployments using container orchestration?

Ans.
Blue-Green Deployments
Concept
Two identical environments:
Blue = current production
Green = new version
Switch traffic all at once after validation.

Canary Deployments
Concept
Gradually shift traffic to the new version
Observe metrics before full rollout

How do you manage multiple environments using reusable infrastructure code?

Ans. We will use Terraform Modules.
Key Idea
Modules = reusable building blocks
envs/ = thin composition layer


What is the purpose of backends in infrastructure-as-code and how do you implement remote state with locking?

Ans. Remote state means storing Terraform state in a shared backend (like S3, Azure Storage, GCS).
Locking ensures that only one Terraform operation can modify the state at a time.

AWS: S3 Backend with DynamoDB Locking (Most Common)
Architecture
S3 → stores terraform.tfstate
DynamoDB → provides state locking and consistency

How do you implement rollback in an automated deployment pipeline?
Ans. By running the below command we can rollbacK:

kubectl rollout undo deployment my-app

Automated Rollback Trigger
Readiness probe fails
Liveness probe fails
Post-deploy smoke tests fail

How do readiness and liveness probes work and why are they important in production environments?
Ans. 
In Kubernetes, readiness and liveness probes are health checks that tell the platform when to send traffic to a pod and when to restart it. 
They are fundamental for stability, zero-downtime deployments, and self-healing in production.

If Readiness fails: Kubernetes:
Removes the pod from Service endpoints
Stops routing traffic to it
Pod is NOT restarted

Why it matters in production?
Prevents traffic going to half-started or degraded pods
Enables zero-downtime deployments

Liveness Probe:
What it does
   Answers: “Is this pod still alive or stuck?”
If it fails, Kubernetes:
    Restarts the container

How do you troubleshoot a pod that is stuck in CrashLoopBackOff?
Ans.
Check Pod Status & Events (Always First)
kubectl get pod <pod-name>
kubectl describe pod <pod-name>

Check container logs:
kubectl logs <pod-name> -c <container-name>
kubectl logs <pod-name> -c <container-name> --previous

Common errors:
Missing or Wrong Configuration

Image Issues
Wrong image tag
Image incompatible with runtime

How do you secure sensitive data like passwords or API keys in infrastructure setups?
Ans. Use password Vaults, AWS Secrets

How does your GitOps tool detect drift and how do you manage it?

Write a script to monitor a service and restart it if it fails, including proper logging.

How do you handle parallel execution in CI/CD workflows?
Ans. Parallel execution can be done through Master- Slave configuration, in order to speed up the deployment and delivery. 

Why Parallel Execution Matters
  Reduces pipeline execution time
  Faster feedback to developers
  Better resource utilization
  Scales with microservices and large test suites

What’s the difference between using count and for_each in infrastructure code, and when should you use each?
How do you monitor and alert on cloud resources effectively?

3rd Round - Synechron,  Client -Morgan Stanley,  Interviewer—Director and Senior DevOps Engineer.

All the questions are scenario-based and counter questions. - I have remembered these question , all the counter questions into CICD related and Kubernets.
----------------*----------------*----------------------*--------------------
1. Can you explain what CI/CD is and describe how you have implemented CI/CD pipelines in one of your projects?


2. How does an AWS CodePipeline differ from a Jenkins pipeline? Can you give an example of when you would choose one over the other?

3. How do you configure your CI/CD pipelines? Can you walk me through the steps you followed to set up a pipeline in a recent project?

4. If you need to deploy an application to both cloud environments and on-premises servers (hybrid environment), how would you design and configure your pipeline 
to handle this?

5. Where and how do you manage environment variables for your applications in a CI/CD setup?  Can you explain how you write and use them securely?

Ans.
Where Environment Variables Are Managed

A. CI/CD Platform (Pipeline Level)
Used for:
Build-time configuration
Tokens for registries, scanners, and cloud access
Examples:
GitHub Actions → Secrets & Variables
GitLab CI → CI/CD Variables
Jenkins → Credentials Store


6. After an application is deployed, what post-deployment steps do you typically perform to ensure everything is running smoothly?
Ans. Once Appliation is deployeed, we will be doing end to end smoke test and closely monitor the metrics. 

7. Can you explain how you would deploy a Kubernetes application using Jenkins? What plugins or tools would you use?
Ans. 

Tools & Plugins Used
Core Jenkins Plugins
Purpose	Plugin
Pipeline as Code	Pipeline
Git integration	Git
Credentials management	Credentials Binding
Docker	Docker Pipeline
Kubernetes agents	Kubernetes Plugin
Approvals	Input Step
Notifications	Email / Slack plugins

Kubernetes Deployment Tools
kubectl	
Helm	

To deploy a Kubernetes application using Jenkins, I use Jenkins as the orchestration layer with pipeline-as-code. 
The pipeline builds and tests the application, creates and pushes a container image, and deploys it to Kubernetes using Helm or kubectl. 
Jenkins authenticates using a restricted service account, environment-specific configurations are handled through Helm values or Kustomize, 
and rollouts are verified with Kubernetes health checks. 

Plugins like Kubernetes, Docker Pipeline, and Credentials Binding enable scalable, secure deployments.


8. What is the difference between git pull and git clone?
Ans.
git clone -Creates a new local copy of a remote repository

Git Pull - It will pull the code from the remote repository and merge into your local.

git pull = git fetch + git merge

9. Can you describe the difference between git pull and git fetch? When would you use one instead of the other?

10. What is git pull vs. git fetch? What is git merge?

11. Suppose you have two commits. How would you check the differences between them?
Ans. git diff <commit1> <commit2>
This shows:
Added lines
Removed lines
Modified lines

12. What are Prometheus and Grafana? Can you explain it ?

13. How do you monitor the health and performance of your Kubernetes pods in a production environment?

14. What is Helm, and why do you prefer to use it for managing Kubernetes applications instead of deploying them normally?

Ans. 
Helm is a package manager for Kubernetes. 
It lets you define, install, upgrade, and rollback Kubernetes applications in a repeatable and scalable way, instead of manually applying raw YAML files.
Helm flow diagram:
chart/
├── Chart.yaml        # Metadata
├── values.yaml       # Default configuration
├── templates/        # Kubernetes manifests with placeholders
└── charts/           # Dependencies (optional)


15. Can you describe the main components of a Kubernetes cluster and explain the role each one plays?
16. If you want to use the feature branch instead of the main branch, how will you design the CICD?
17.  If any issue occurred in PIPELINE, who handled the issues, and how do the troubleshoot?
